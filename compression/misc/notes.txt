can get rle using sines



convert to base 4
seperate #'s (1,2,3. Don't bother with 0's)
  convert to base 4 again
x  remove blanks
  apply equation





possible eqtn for x=position, y=length for RLE



what if we preprocess the data from bytes to 3 sets of qit references (in bits) saying >=1, >=2, and >=3

could give much longer runs (would it be enough to offset 



basically all files have exponentially decaying number of run lengths (eg 1000 lengths of 1, 500 length 2, 250 len 3, 125 len 4...)


could split the data into chunks, then reference what positions in that chunk are single switches (split to reduce number of reference bits)?



what about looking at how many numbers can be generated by a^b where a and b are intgers from 0 to 255 (1byte each)
could look at splitting data into pieces ensuring they always end with a 0 so they won't be prime, then checking if they can be calculated
also need to either never have leading 0's or count the number of leading zeros (or count the number of bits to be generated and zero pad






okay, so the rle preprocessing doesn't work (it kinda does, but not as well as I was hoping)
so what else can we try to reduce entropy?
I like the idea of the oscillator, I think that could be explored more

what about going back to the exponential one? I think that could definitely be explored more

otherwise, how else can we improve the rle type?
need to focus on lengthening the the 1's
could do that by breaking the data into smaller chunks, would need to record the output bit length, and ensure that the data is shortened by at least enough to break even (else just use the original data)

data structure could look something like:

x is processed (use the original data or not)
x seed
xxxxxxxx # of bits/bytes/units to be processed
xxxxx 



