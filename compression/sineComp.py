'''
x(t) = a0+sum(am*cos(M*t),m,-inf,inf)+sum(bn*sin(N*t),n,-inf,inf)
m,n=integers
M,N=2pi(m,n)/T
T=fundimental period (length of dataset)

What are a0/am/bn given x(t)?
a0 = 1/T*int(x(t)dt,0,T)
am = 2/T*int(x(t)*cos(Mt)dt,0,T)
bn = 2/T*int(x(t)*sin(Nt)dt,0,T)
'''

from common import *
import sys
from scipy.integrate import quad
from matplotlib import pyplot as plt

#attempt to "compress" the data
#fullData is the data to compress as a binary string
#window is the number of bits to divide the data into
#resolution = number of samples per bit when error checking
#roundconst = round the constants to this many decimal places
def apply(fullData, window, resolution=10,roundconst=2, plotData=True, verbose=False):
  ftdata = [] #data generated by the fourier transform
  ftterms = [] #terms generated by the fourier transform, should be formatted as list of lists of terms
  winStart=winEnd=0 #starting point for where the window should be placed
  
  #while there's still data to process
  while winEnd<len(fullData):
    ftterms.append([]) #append the next set of data
    winStart = winEnd #set the starting bit to the last ending bit (since data is captured from start (inclusive) to end (exclusive))
    winEnd = winStart+min(len(fullData)-winStart,window) #set the end to either the window length or the remaining data points
    datachunk = [int(e) for e in fullData[winStart:winEnd]] #get the data from the start to end points
    
    m=n=0 #m and n constants in the fourier transform
    T = len(datachunk) #T constant in the fourier transform
    
    a0 = round(1/T*sum(datachunk),roundconst) #because data is square waves of height=1, then the integral over a period is simply the sums of the 1's
    ftterms[-1] += [a0] # set the first element of the latest list of constants to the dc offset
    
    #keep adding terms until the approximation becomes good enough
    while ftdata!=datachunk: #do until data is valid
      n+=1 #summation starts at 1 and can go up to infinity
      m+=1
      # am = round(2/T*quad(cosfxn,0,T,args=(2*pi*m/T,datachunk))[0],roundconst)
      # bn = round(2/T*quad(sinfxn,0,T,args=(2*pi*n/T,datachunk))[0],roundconst)
      am = 2/T*quad(cosfxn,0,T,args=(2*pi*m/T,datachunk))[0]
      bn = 2/T*quad(sinfxn,0,T,args=(2*pi*n/T,datachunk))[0]
      #have a cutoff that if the abs(am|bn)<cutoff: am|bn=0, reduce data
      # print(am,bn,end="\t")
      constCutoff = 0.04
      if(abs(am)<=constCutoff): am=0
      if(abs(bn)<=constCutoff): bn=0
      # print(am,bn,end="\t")
      #TODO: round constants to nearest power of 2 of the number of bits we want
      bitsPerConst = 5
      am = roundbits(am,bitsPerConst)
      bn = roundbits(bn,bitsPerConst)
      # print(am,bn)
      
      
      #append the new terms onto the recorded fourier transform
      ftterms[-1] += [[am,bn]]
      
      ts = [i/resolution for i in range(resolution*len(datachunk))] #generate the time samples at the given resolution
      y = calcFxn(ftterms,ts,m,n,T) 
      
      #generate ftdata from y - group by resolution size, round the average of each group if >a0
      ftdata = zip(*(iter([round(e) for e in y]),)*resolution)
      ftdata = [int(round(sum(e)/len(e))>a0) for e in ftdata]

      if(verbose): print(*datachunk,sep="")
      if(verbose): print(*ftdata,sep="",end="\t")
      if(verbose): print(ftdata==datachunk,n,end="\n\n")
      

    
    
    #plot the data
    if(plotData):
      plt.plot(ts,y,label="ft")
      origdata = [datachunk[int(t)] for t in ts]
      recondata = [round(e) for e in y] #round to get appx values
      
      #generate plottable data
      recondata = zip(*(iter(recondata),) * resolution)
      recondata = [round(sum(e)/len(e)) for e in recondata]
      recondata = [recondata[int(e/resolution)] for e in range(len(recondata)*resolution)]
      
      plt.plot(ts,origdata,label="orig")
      plt.plot(ts,recondata,label="recon")
      plt.legend(bbox_to_anchor=(1,1), loc="upper left")
      plt.grid(True)
      plt.show()
    
  return ftterms



#attempt to "decompress" the data
#fullData is the binary string of the applied function
#should return the original data
def unapply(fullData):
  return None





if(len(sys.argv)!=2):
  raise ValueError("please pass a numeric number of bytes as an argument")
else:
  rndBytes = int(sys.argv[1])
fullData = getRandData(rndBytes,fromFile=True)
fullData = "".join([int2base(e,2,8) for e in fullData])
#window = int(input("window size:"))

#fullData = [1,1,0,0]
window=len(fullData)

print(fullData,window)
c = apply(fullData,window)
print(*c,sep="\n")
